# 数据库基本理论

- [数据库基本理论](#数据库基本理论)
  - [什么是范式和反范式？](#什么是范式和反范式)
    - [什么是第一、二、三、BC 范式？](#什么是第一二三bc-范式)
    - [范式常用概念](#范式常用概念)
      - [实体（Entity）](#实体entity)
      - [数据项（Data Item）](#数据项data-item)
      - [数据元素（Data Element）](#数据元素data-element)
      - [码](#码)
      - [主属性](#主属性)
      - [非主属性](#非主属性)
      - [依赖表（Dependent Table）](#依赖表dependent-table)
      - [关联表（Associative Table）](#关联表associative-table)
      - [依赖](#依赖)
    - [范式特征详解表格](#范式特征详解表格)
    - [第一范式（1NF）：属性不可分](#第一范式1nf属性不可分)
    - [第二范式（2NF）：非主属性完全依赖于码](#第二范式2nf非主属性完全依赖于码)
    - [第三范式（3NF）](#第三范式3nf)
    - [BCNF（Boyce-Codd Normal Form）](#bcnfboyce-codd-normal-form)
  - [符合不同范式的数据库设计](#符合不同范式的数据库设计)
    - [第一范式](#第一范式)
    - [第二范式/第三范式](#第二范式第三范式)
  - [反范式](#反范式)
    - [优点](#优点)
    - [缺点](#缺点)
    - [反范式技术](#反范式技术)
    - [反范式示例](#反范式示例)
  - [事务的概念及其4个特性](#事务的概念及其4个特性)
  - [事务的常见分类](#事务的常见分类)
    - [扁平事务](#扁平事务)
    - [带有保存点的扁平事务](#带有保存点的扁平事务)
    - [链事务](#链事务)
    - [嵌套事务](#嵌套事务)
    - [分布式事务](#分布式事务)
  - [XA 事务](#xa-事务)
  - [事务的4种隔离级别（Isolation Level）](#事务的4种隔离级别isolation-level)
    - [Read Uncommitted（未提交读，读取未提交内容）](#read-uncommitted未提交读读取未提交内容)
    - [Read Committed（提交读，读取提交内容）](#read-committed提交读读取提交内容)
    - [Repeatable Read（可重复读）](#repeatable-read可重复读)
    - [Serializable（可串行化、序列化）](#serializable可串行化序列化)
  - [Oracle、MySQL 和 SQL Server 中的事务隔离级别](#oraclemysql-和-sql-server-中的事务隔离级别)
    - [Oracle 中的事务隔离级别](#oracle-中的事务隔离级别)
    - [MySQL中的事务隔离级别](#mysql中的事务隔离级别)
    - [SQL Server中的事务隔离级别](#sql-server中的事务隔离级别)
  - [CAP定理（CAP theorem）](#cap定理cap-theorem)
    - [CAP 和 ACID 一致性的区别](#cap-和-acid-一致性的区别)

## 什么是范式和反范式？

当设计关系型数据库时，需要遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式（Normal Form），越高的范式数据库冗余越小。应用数据库范式可以带来许多好处，但是最主要的目的是为了消除重复数据，减少数据冗余，更好地组织数据库内的数据，让磁盘空间得到更有效的利用。范式的缺点：范式使查询变得相当复杂，在查询时需要更多的连接，一些复合索引的列由于范式化的需要被分割到不同的表中，导致索引策略不佳。

### 什么是第一、二、三、BC 范式？

所谓“第几范式”，是表示关系的某一种级别，所以经常称某一关系 R 为第几范式。目前关系型数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以此类推。一般说来，**数据库只需满足第三范式（3NF）就行了**。满足高等级的范式的先决条件是必须先满足低等级范式。

在关系数据库中，关系是通过表来表示的。在一个表中，每一行代表一个联系，而一个关系就是由许多的联系组成的集合。所以，在关系模型中，关系用来指代表，而元组用来指代行，属性就是表中的列。对于每一个属性，都存在一个允许取值的集合，称为该属性的域。

### 范式常用概念

![](../imgs/term.png)

![](../imgs/term2.png)

#### 实体（Entity）

就是实际应用中要用数据描述的事物，它是**现实世界中客观存在并可以被区别的事物**，一般是名词。比如“一个学生”、“一本书”、“一门课”等等。需要注意的是，这里所说的“事物”不仅仅是看得见摸得着的“东西”，它也可以是虚拟的，比如说“老师与学校的关系”。

#### 数据项（Data Item）

即**字段（Fields）**也可称为**域**、**属性**、**列**。**数据项是数据的不可分割的最小单位**。数据项可以是字母、数字或两者的组合。通过数据类型（逻辑的、数值的、字符的等）及数据长度来描述。数据项用来描述实体的某种属性。数据项包含数据项的名称、编号、别名、简述、数据项的长度、类型、数据项的取值范围等内容。教科书上解释为：“实体所具有的某一特性”，由此可见，属性一开始是个逻辑概念，比如说，“性别”是“人”的一个属性。在关系数据库中，属性又是个物理概念，**属性可以看作是“表的一列”**。

#### 数据元素（Data Element）

数据元素是数据的基本单位。数据元素也称**元素**、**行**、**元组**、**记录（Record）**。一个数据元素可以由若干个数据项组成。表中的一行就是一个元组。

#### 码

也称为**键（Key）**，它是数据库系统中的基本概念。所谓码就是**能唯一标识实体的属性**，它是**整个实体集的性质**，而不是单个实体的性质，包括超码、候选码、主码和全码。

- **超码**：**超码是一个或多个属性的集合**，这些属性的组合**可以在一个实体集中唯一地标识一个实体**。如果 K 是一个超码，那么 K 的任意超集也是超码，也就是说如果 K 是超码，那么所有包含 K 的集合也是超码。
- **候选码**：在一个超码中，可能包含了无关紧要的属性，如果对于一些超码，他们的任意真子集都不能成为超码，那么这样的最小超码称为候选码。
- **主码**：**候选码中最少键的组合**，它就叫**主码（主键，Primary Key）**。每个主码应该具有下列特征：
  - 唯一
  - 最小，尽量选择**最少键**的组合
  - 非空
  - **不可更新**，不能随时更改
- **全码**：如果一个码包含了所有的属性，这个码就是全码（All-key）。
- **外码**：关系模式 R 中的一个属性或属性组 X 并非 R 的码，但 X 是另一个关系模式的码，则称 X 是 R 的外码，也称**外键（Foreign Key）**。主码与外码一起提供了**表示关系间联系**的手段。

#### 主属性

一个属性只要**在任何一个候选码中出现过**，这个属性就是主属性（Prime Attribute）。

#### 非主属性

与主属性相反，**没有在任何候选码中出现过**，这个属性就是**非主属性**（Nonprime Attribute）或**非码属性**（Non-key Attribute）。

#### 依赖表（Dependent Table）

也称为弱实体（Weak Entity）是需要**用父表标识的子表**。

#### 关联表（Associative Table）

是多对多关系中**两个父表的子表**。

#### 依赖

- **函数依赖**：函数依赖是指**关系中一个或一组属性的值可以决定其他属性的值**。函数依赖就像一个函数 `y=f(x)` 一样，**x 的值给定后，y 的值也就唯一地确定了**，写作 `X→Y`。函数依赖不是指关系模式 R 的某个或某些关系满足的约束条件，而是指 **R 的一切关系均要满足的约束条件**。
- **完全函数依赖**：在一个关系中，若**某个非主属性数据项依赖于全部关键字称之为完全函数依赖**。例如，在成绩表（学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课程号也不能决定成绩，所以“（学号，课程号）→成绩”就是完全函数依赖。
- **传递函数依赖**：指的是如果存在 “A→B→C” 的决定关系，则 C 传递函数依赖于 A。

### 范式特征详解表格

![](../imgs/1nf.png)

![](../imgs/2nf_3nf.png)

### 第一范式（1NF）：属性不可分

所谓第一范式（1NF）是指在关系模型中，对域添加的一个规范要求，**所有的域都应该是原子性的**，即**数据库表的每一列都是不可分割的原子数据项**，而不能是集合、数组、记录等非原子数据项。即当实体中的某个属性有多个值时，必须将其拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。例如，由“职工号”、“姓名”、“电话号码”组成的职工表，由于一个人可能有一个办公电话和一个移动电话，所以，这时可以将其规范化为1NF。将电话号码分为“办公电话”和“移动电话”两个属性，即职工表（职工号，姓名，办公电话，移动电话）。

需要注意的是，在任何一个关系型数据库中，**第一范式（1NF）是对关系模式的设计基本要求**，一般设计时都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。不满足1NF的数据库就不是关系数据库。**满足1NF的表必须要有主键且每个属性不可再分**。

### 第二范式（2NF）：非主属性完全依赖于码

在1NF的基础上，**每一个非主属性必须完全依赖于码**（在1NF基础上，**消除非主属性对主键的部分函数依赖**）。

第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的**每个实例或记录必须可以被唯一地区分**。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。

例如，在选课关系表（学号，课程号，成绩，学分）中，码为组合关键字（学号，课程号）。但是，由于**非主属性学分仅仅依赖于课程号**，对关键字（学号，课程号）只是部分依赖，而不是完全依赖，所以，此种方式会导致数据冗余、更新异常、插入异常和删除异常等问题，其设计不符合2NF。解决办法是将其分为两个关系模式：学生表（学号，课程号，分数）和课程表（课程号，学分），新关系通过学生表中的外键字课程号联系，在需要时通过两个表的连接来取出数据。

第二范式（2NF）要求**实体的属性完全依赖于主关键字**。所谓完全依赖是指**不能存在仅依赖主关键字一部分的属性**，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。

**所有单关键字的数据库表都符合第二范式**，因为不可能存在组合关键字。

### 第三范式（3NF）

在1NF基础上，每个非主属性既不部分依赖于码也不传递依赖于码（**在2NF基础上消除传递依赖**）。如果关系模式R是第二范式，且每个非主属性都不传递依赖于R的码，则称R是第三范式的模式。第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）前必须先满足第二范式（2NF）。

例如，学生表（学号，姓名，课程号，成绩），其中学生姓名若无重名，所以，该表有两个候选码（学号，课程号）和（姓名，课程号），则存在函数依赖：学号→姓名，（学号，课程号）→成绩，（姓名，课程号）→成绩，唯一的非主属性成绩对码不存在部分依赖，也不存在传递依赖，所以，属于第三范式。

满足第三范式的数据库表应该不存在如下依赖关系：

关键字段 → 非关键字段 x → 非关键字段 y

假定学生关系表为（学号，姓名，年龄，所在学院，学院地点，学院电话），关键字为单一关键字“学号”，因为存在如下决定关系：

（学号）→（姓名，年龄，所在学院，学院地点，学院电话）

这个关系是符合2NF的，但是不符合3NF，因为存在如下决定关系：

（学号）→（所在学院）→（学院地点，学院电话）

即存在非关键字段“学院地点”、“学院电话”对关键字段“学号”的传递函数依赖。它也会存在数据冗余、更新异常、插入异常和删除异常的情况。把学生关系表分为如下两个表：

学生：（学号，姓名，年龄，所在学院）；

学院：（学院，地点，电话）。

这样的数据库表是符合第三范式的，**消除了数据冗余、更新异常、插入异常和删除异常**。

### BCNF（Boyce-Codd Normal Form）

在1NF基础上，**任何非主属性不能对主键子集依赖**（在3NF基础上**消除对主键子集的依赖**）。

若关系模式R是第一范式，且每个属性（包括主属性）既不存在部分函数依赖也不存在传递函数依赖于R的候选键，这种关系模式就是BCNF模式。即在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合BCNF。BCNF是修正的第三范式，有时也称扩充的第三范式。

BCNF是第三范式（3NF）的一个子集，即满足BCNF必须满足第三范式（3NF）。通常情况下，BCNF被认为没有新的设计规范加入，只是对第二范式与第三范式中设计规范要求更强，因而被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，使数据库冗余度更小。这也是BCNF不被称为第四范式的原因。

对于BCNF，在主键的任何一个真子集都不能决定于主属性。关系中U主键，若U中的任何一个真子集X都不能决定于主属性Y，则该设计规范属性BCNF。例如：在关系R中，U为主键，A属性是主键中的一个属性，若存在A->Y，Y为主属性，则该关系不属于BCNF。

假设仓库管理关系表（仓库号，存储物品号，管理员号，数量），满足一个管理员只在一个仓库工作；一个仓库可以存储多种物品。则存在如下关系：

（仓库号，存储物品号）→（管理员号，数量）
（管理员号，存储物品号）→（仓库号，数量）

所以，（仓库号，存储物品号）和（管理员号，存储物品号）都是仓库管理关系表的候选码，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：

（仓库号）→（管理员号）
（管理员号）→（仓库号）

**即存在关键字段决定关键字段的情况**，所以，其不符合BCNF范式。把仓库管理关系表分解为二个关系表：仓库管理表（仓库号，管理员号）和仓库表（仓库号，存储物品号，数量），这样的数据库表是符合BCNF范式的，消除了删除异常、插入异常和更新异常。

## 符合不同范式的数据库设计

学习了范式，为了巩固理解，接下来设计一个论坛的数据库，该数据库中需要存放如下信息：

1. 用户：用户名，EMAIL，主页，电话，联系地址。
2. 帖子：发帖标题，发帖内容，回复标题，回复内容。

### 第一范式

第一次可以将数据库设计为仅仅存在的一张表：

```
用户名 EMAIL 主页 电话 联系地址 发帖标题 发帖内容 回复标题 回复内容
```

这个数据库表符合第一范式，但是没有任何一组候选关键字能决定数据库表的整行，唯一的关键字段用户名也不能完全决定整个元组。

所以，需要增加“发帖ID”、“回复ID”字段，即将表修改为：

用户名 EMAIL 主页 电话 联系地址 发帖ID 发帖标题 发帖内容 回复ID 回复标题 回复内容

这样数据表中的关键字（用户名，发帖ID，回复ID）能决定整行：

（用户名，发帖ID，回复ID）→（EMAIL，主页，电话，联系地址，发帖标题，发帖内容，回复标题，回复内容）

但是，这样的设计不符合第二范式，因为存在如下决定关系：

（用户名）→（EMAIL，主页，电话，联系地址）

（发帖ID）→（发帖标题，发帖内容）

（回复ID）→（回复标题，回复内容）

即非关键字段部分函数依赖于候选关键字段，很明显，这个设计会导致大量的数据冗余和操作异常。

### 第二范式/第三范式

对这张表进行分解，具体可以分解为（带下划线的为关键字）：

1. 用户信息：用户名，EMAIL，主页，电话，联系地址。
2. 帖子信息：发帖ID，标题，内容。
3. 回复信息：回复ID，标题，内容。
4. 发贴：用户名，发帖ID。
5. 回复：发帖ID，回复ID。

这样的设计是满足第一、二、三范式和BCNF范式要求的。但是这样的设计不一定是最好的。

观察可知，第4项“发帖”中的“用户名”和“发帖ID”之间是1∶N的关系，因此，可以把“发帖”合并到第2项的“帖子信息”中；第5项“回复”中的“发帖ID”和“回复ID”之间也是1∶N的关系，因此，可以把“回复”合并到第3项的“回复信息”中。这样可以一定程度地减少数据冗余，新的设计如下所示：

1. 用户信息：用户名，EMAIL，主页，电话，联系地址。
2. 帖子信息：用户名，发帖ID，标题，内容。
3. 回复信息：发帖ID，回复ID，标题，内容。

数据库表1显然满足所有范式的要求。

数据库表2中存在非关键字段“标题”、“内容”对关键字段“发帖ID”的部分函数依赖，满足第二范式的要求，但是这一设计并不会导致数据冗余和操作异常。

数据库表3中也存在非关键字段“标题”、“内容”对关键字段“回复ID”的部分函数依赖，也不满足第二范式的要求，但是与数据库表2相似，这一设计也不会导致数据冗余和操作异常。

由此可以看出，并不一定要强行满足范式的要求，对于1∶N关系，当1的一边合并到N的那边后，N的那边就不再满足第二范式了，但是这种设计反而比较好。

对于M∶N的关系，不能将M一边或N一边合并到另一边去，这样会导致不符合范式要求，同时导致操作异常和数据冗余。

对于1∶1的关系，可以将左边的1或者右边的1合并到另一边去，设计导致不符合范式要求，但是并不会导致操作异常和数据冗余。

所以，满足范式要求的数据库设计是结构清晰的，同时可避免数据冗余和操作异常。这并意味着不符合范式要求的设计一定是错误的，在数据库表中存在1∶1或1∶N关系这种较特殊的情况下，合并导致的不符合范式要求反而是合理的。

所以，在数据库设计的时候，一定要时刻考虑范式的要求。

## 反范式

数据库设计要严格遵守范式，这样设计出来的数据库，虽然思路很清晰，结构也很合理，但是，有时候却要在一定程度上打破范式设计。因为范式越高，设计出来的表可能越多，关系可能越复杂，但是性能却不一定会很好，因为表一多，就增加了关联性。特别是在高可用的OLTP数据库中，这一点表现得很明显，所以就引入了反范式。

不满足范式的模型，就是反范式模型。反范式跟范式所要求的正好相反，在反范式的设计模式中，可以允许适当的数据冗余，用这个冗余可以缩短查询获取数据的时间。反范式其本质上就是用空间来换取时间，把数据冗余在多个表中，当查询时就可以减少或者避免表之间的关联。反范式技术也可以称为反规范化技术。

### 优点

减少了数据库查询时表之间的连接次数，可以更好地利用索引进行筛选和排序，从而减少了I/O数据量，提高了查询效率。

### 缺点

数据存在重复和冗余，存在部分空间浪费。另外，为了保持数据的一致性，则必须维护这部分冗余数据，因此增加了维护的复杂性。所以，在进行范式设计时，要在数据一致性与查询之间找到平衡点，因为符合业务场景的设计才是好的设计。

### 反范式技术

在RDBMS模型设计过程中，常常使用范式来约束模型，但在NoSQL模型中则大量采用反范式。常见的数据库反范式技术包括：

- 增加冗余列：在多个表中保留相同的列，以减少表连接的次数。冗余法以空间换取时间，把数据冗余在多个表中，当查询时可以减少或者是避免表之间的关联。
- 增加派生列：表中增加可以由本表或其他表中数据计算生成的列，减少查询时的连接操作并避免计算或使用集合函数。
- 表水平分割：根据一列或多列的值将数据放到多个独立的表中，主要用于表的规模很大、表中数据相对独立或数据需要存放到多个介质的情况。
- 表垂直分割：对表按列进行分割，将主键和一部分列放到一个表中，主键与其他列放到另一个表中，在查询时减少I/O次数。

### 反范式示例

有学生表与课程表，假定课程表要经常被查询，而且在查询中要显示学生的姓名，则查询语句为：

```sql
select code, name, subject from course c, students s where s.id=c.code where code = ?;
```

如果这个语句被大范围、高频率执行，那么可能会因为表关联造成一定程度的影响，现在，假定评估到学生改名的需求是非常少的，那么，就可以把学生姓名冗余到课程表中。注意：这里并没有省略学生表，只不过是把学生姓名冗余在了课程表中，如果万一有很少的改名需求，只要保证在课程表中改名正确即可。

那么，修改以后的语句可以简化为：

```sql
select code, name, subject from course c where code = ?;
```

| 模型 | 优点 | 缺点 |
| ------------ | ------------ | ------------ |
| 范式化模型   | 数据没有冗余，更新任意 | 当表的数量比较多，查询设计需要很多关联模型（Join）时，会导致查询性能低下 |
| 反范式化模型 | 数据冗余将带来很好的读取性能（因为不需要 Join 很多表，而且通常反范式模型很少做更新操作） | 需要维护冗余数据，从目前 NoSQL 的发展可以看到，对磁盘空间的消耗是可以接受的 |

## 事务的概念及其4个特性

事务（Transaction）是一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。事务通常以 `BEGIN TRANSACTION` 开始，以 `COMMIT` 或 `ROLLBACK` 操作结束，`COMMIT` 即提交，提交事务中所有的操作、事务正常结束。`ROLLBACK `即回滚，撤销已做的所有操作，回滚到事务开始时的状态。事务是数据库系统区别于文件系统的重要特性之一。

对于事务可以举一个简单的例子：转账，有A和B两个用户，A用户转100到B用户，如下所示：

```
A：----> 支出100，则 A-100
B：----> 收到100，则 B+100
```

A--->B 转账

对应如下SQL语句：

```sql
update account
set money=money - 100
where name = 'A';

update account
set money=money + 100
where name = 'B';
```

事务有4个特性，一般都称之为ACID特性，简单记为原一隔持（谐音：愿意各吃，即愿意各吃各的），如下表所示：

![](../imgs/acid.png)

- 原子性：事务在逻辑上是不可分割的操作单元，其所有语句要么执行，要么都撤销执行。当每个事物运行结束时，可以选择“提交”所做的数据修改，并将这些修改永久应用到数据库中。
- 一致性：
- 隔离性：
- 持久性：

## 事务的常见分类

从事务理论的角度来看，可以把事务分为以下几种类型：

- 扁平事务（Flat Transactions）
- 带有保存点的扁平事务（Flat Transactions with Savepoints）
- 链事务（Chained Transactions）
- 嵌套事务（Nested Transactions）
- 分布式事务（Distributed Transactions）

### 扁平事务

是事务类型中最简单的一种，但是在实际生产环境中，这可能是使用最频繁的事务，在扁平事务中，所有操作都处于同一层次，其由 BEGIN WORK 开始，由 COMMIT WORK 或 ROLLBACK WORK 结束，其间的操作是原子的，要么都执行，要么都回滚，因此，扁平事务是应用程序成为原子操作的基本组成模块。扁平事务虽然简单，但是在实际环境中使用最为频繁，也正因为其简单，使用频繁，故每个数据库系统都实现了对扁平事务的支持。扁平事务的主要限制是不能提交或者回滚事务的某一部分，或分几个步骤提交。

保存点（Savepoint）用来通知事务系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。对于扁平的事务来说，隐式的设置了一个保存点，然而在整个事务中，只有这一个保存点，因此，回滚只能会滚到事务开始时的状态。

扁平事务一般有三种不同的结果：①事务成功完成。在平常应用中约占所有事务的96%。②应用程序要求停止事务。比如应用程序在捕获到异常时会回滚事务，约占事务的3%。③外界因素强制终止事务。如连接超时或连接断开，约占所有事务的1%。

### 带有保存点的扁平事务

除了支持扁平事务支持的操作外，还允许在事务执行过程中回滚到同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销太大。

### 链事务

是指**一个事务由多个子事务链式组成**，它可以被视为保存点模式的一个变种。带有保存点的扁平事务，当发生系统崩溃时，所有的保存点都将消失，这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行。链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务，前一个子事务的提交操作和下一个子事务的开始操作合并成一个原子操作，这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行一样。这样，在提交子事务时就可以释放不需要的数据对象，而不必等到整个事务完成后才释放。

![](../imgs/chained_transactions.png)

链事务与带有保存点的扁平事务的不同之处体现在：

① 带有保存点的扁平事务能回滚到任意正确的保存点，而**链事务中的回滚仅限于当前事务**，即只能恢复到最近的一个保存点。

② 对于锁的处理，两者也不相同，链事务在执行 COMMIT 后即释放了当前所持有的锁，而带有保存点的扁平事务不影响迄今为止所持有的锁。

### 嵌套事务

是一个层次结构框架，由一个顶层事务（Top-Level Transaction）控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务（Subtransaction），其控制着每一个局部的变换，子事务本身也可以是嵌套事务。因此，嵌套事务的层次结构可以看成是一棵树。

### 分布式事务

通常是在一个分布式环境下运行的扁平事务，因此，需要根据数据所在位置访问网络中不同节点的数据库资源。例如，一个银行用户从招商银行的账户向工商银行的账户转账1000元，这里需要用到分布式事务，因为不能仅调用某一家银行的数据库就完成任务。

## XA 事务

XA（eXtended Architecture）是指由 X/Open 组织提出的分布式交易处理的规范。XA 是一个分布式事务协议，由 Tuxedo 提出，所以，分布式事务也称为 XA 事务。XA 协议主要定义了事务管理器（TM，Transaction Manager，协调者）和资源管理器（RM，Resource Manager，参与者）之间的接口。其中，资源管理器往往由数据库实现，例如 Oracle、DB2、MySQL，这些商业数据库都实现了 XA 接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。XA 事务是基于两阶段提交（Two-phase Commit，2PC）协议实现的，可以保证数据的强一致性，许多分布式关系型数据管理系统都采用此协议来完成分布式。阶段一为准备阶段，即所有的参与者准备执行事务并锁住需要的资源。当参与者 Ready 时，向 TM 汇报自己已经准备好。阶段二为提交阶段。当 TM 确认所有参与者都 Ready 后，向所有参与者发送 COMMIT 命令。

XA 事务允许不同数据库的分布式事务，只要参与在全局事务中的每个节点都支持 XA 事务。Oracle、MySQL和 SQL Server 都支持 XA 事务。

- XA 事务由一个或多个资源管理器（RM）、一个事务管理器（TM）以及一个应用程序（Application Program）组成。
- 资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器。
- 事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。
- 应用程序：定义事务的边界。

XA 事务的缺点是性能不佳，且 XA 无法满足高并发场景。一个数据库的事务和多个数据库间的 XA 事务性能会相差很多。因此，要尽量避免使用 XA 事务，例如可以将数据写入本地，用高性能的消息系统分发数据，或使用数据库复制等技术。只有在其他办法都无法实现业务需求，且性能不是瓶颈时才使用 XA。

## 事务的4种隔离级别（Isolation Level）

当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，所以，对于不同的事务，采用不同的隔离级别会有不同的结果。如果不考虑事务的隔离性，那么会发生下表所示的3种问题：

![](../imgs/isolation.png)

脏读和不可重复读的区别为：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是在同一个事务范围内多次查询同一条数据却返回了不同的数据值，这是由于在查询间隔期间，该条数据被另一个事务修改并提交了。

幻读和不可重复读的区别为：幻读和不可重复读都是读取了另一个事务中已经提交的数据，不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一个数据整体（例如数据的条数）。

在SQL标准中定义了4种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些是在事务内和事务间可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。SQL标准定义的四个隔离级别为：Read Uncommitted（未提交读）、Read Committed（提交读）、Repeatable Read（可重复读）、Serializable（可串行化）。

![](../imgs/isolation_level.png)

### Read Uncommitted（未提交读，读取未提交内容）

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果，即在未提交读级别，事务中的修改，即使没有提交，对其他事务也都是可见的，该隔离级别很少用于实际应用。读取未提交的数据，也被称之为脏读（Dirty Read）。该隔离级别最低，并发性能最高。

### Read Committed（提交读，读取提交内容）

这是大多数数据库系统的默认隔离级别。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。

### Repeatable Read（可重复读）

可重复读可以确保同一个事务，在多次读取同样数据的时候，得到同样的结果。可重复读解决了脏读的问题，不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。MySQL数据库中的InnoDB和Falcon存储引擎通过MVCC（Multi-Version Concurrent Control，多版本并发控制）机制解决了该问题。需要注意的是，多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。

### Serializable（可串行化、序列化）

这是最高的隔离级别，它通过强制事务排序，强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能出现大量的超时现象和锁竞争。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑用该级别。这是花费代价最高但是最可靠的事务隔离级别。

不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差。

## Oracle、MySQL 和 SQL Server 中的事务隔离级别

![](../imgs/oracle_mysql_sqlserver_isolation.png)

![](../imgs/oracle_mysql_sqlserver_isolation2.png)

### Oracle 中的事务隔离级别

Oracle数据库支持Read Committed（提交读）和Serializable（可串行化）这两种事务隔离级别，提交读是Oracle数据库默认的事务隔离级别，Oracle不支持脏读。SYS用户不支持Serializable（可串行化）隔离级别。

### MySQL中的事务隔离级别

MySQL数据库支持Read Uncommitted（未提交读）、Read Committed（提交读）、Repeatable Read（可重复读）和Serializable（可串行化）这4种事务隔离级别，其中，Repeatable Read（可重复读）是MySQL数据库的默认隔离级别。

### SQL Server中的事务隔离级别

SQL Server共支持6种事务隔离级别，分别为：Read Uncommitted（未提交读）、Read Committed（提交读）、Repeatable Read（可重复读）、Serializable（可串行化）、Snapshot（快照）、Read Committed Snapshot（已经提交读隔离）。SQL Server数据库默认的事务隔离级别是Read Committed（提交读）。

## CAP定理（CAP theorem）

CAP定理又称CAP原则是一个衡量系统设计的准则。CAP定理指的是在一个分布式系统中，Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性），三者不可兼得。

- C（一致性）：所有节点在同一时间的数据完全一致；
- A（可用性）：服务一直可用，每个请求都能接收到一个响应，无论响应成功或失败；
- P（分区容错性）：分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

任何分布式系统在可用性、一致性、分区容错性方面，不能兼得，最多只能得其二。因此，任何分布式系统的设计只是在三者中的不同取舍而已。所以，就有了3个分类：CA数据库，CP数据库和AP数据库。传统的关系型数据库在功能支持上通常很宽泛，从简单的键值查询，到复杂得多表联合查询再到事务机制的支持。而与之不同的是，NoSQL系统通常注重性能和扩展性，而非事务机制，因为事务就是强一致性的体现。

- CP数据库考虑的是一致性和分区容错性，这种数据库对分布式系统内的通信要求比较高，因为要保持数据的一致性，需要做大量的交互，如Oracle RAC、Sybase集群。虽然Oracle RAC具备一定的扩展性，但当节点达到一定数目时，性能（即可用性）就会下降很快，并且节点之间的网络开销还在，需要实时同步各节点之间的数据。CP数据库通常性能不是特别高，例如火车售票系统。
- AP数据库考虑的是实用性和分区容忍性，即外部访问数据，可以更快地得到回应，例如博客系统。这时候，数据的一致性就可能得不到满足或者对一致性要求低一些，各节点之间的数据同步没有那么快，但能保存数据的最终一致性。比如一个数据，可能外部一个进程在改写这个数据，同时另一个进程在读这个数据，此时，数据显现是不一致的。但是有一点，就是数据库会满足一个最终一致性的概念，即过程可能是不一致的，但是到某一个终点，数据就会一致起来。当前热炒的NoSQL大多是典型的AP类型数据库。

### CAP 和 ACID 一致性的区别

一般事务ACID中的一致性是有关数据库规则的描述，如果数据表结构定义一个字段值是唯一的，那么一致性系统将解决所有操作中导致这个字段值非唯一性的情况，如果带有一个外键的一行记录被删除，那么其外键相关记录也应该被删除，这就是ACID一致性意思。

CAP理论的一致性是保证同一个数据在所有不同服务器上的拷贝都是相同的，这是一种逻辑保证，而不是物理，因为网络速度限制，在不同服务器上这种复制是需要时间的，集群通过阻止客户端查看不同节点上还未同步的数据维持逻辑视图。
